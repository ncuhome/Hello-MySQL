## 如何优化一个查询

Select 是数据库中最常用的操作之一, 因为数据也是文件系统一种, 而文件系统最基本的功能就是读和写, 而select提供了数据的读功能, 最基本的Select语句为select a from b where c = x. select的操作包含大量的优化, 首先就是查看查询的瓶颈在哪里, 使用explain.

### 从关系代数的优化说起

因为数据库的数学基础是关系代数, 所以针对关系代数我们可以做一些优化. sql语句可以写成ast, 所以关系描述的数学表示也可以写成树的结构, 通过优化ast表达树的优化方式被称为逻辑优化, 也就是常说的选择下推, 投影下推和联接优化. 
  - 选择下推是指在联接操作中, 将顶层的条件向下推, 使得联接子句所得的数据尽可能的少. 
  - 投影下推是指在子句查询或者联接查询中, 把顶层的属性下推到子句中, 使得子查询或者联接查询得到的列尽可能的少.
  - 联接优化一般指优化联接方式和联接顺序,  联接方式涉及到左联接 left join, 右联接 right join, 内联接 inner join, 能用inner join就不用其他的联接方式, 联接顺序优化指小表驱动大表, 避免在大表上扫描无用的数据. 关于联接还有一个情况是union的查询优化, 因为union查询的特殊性所以必须自己做下推操作, 但有一点需要注意, union的查询如果不是必须的, 一定加上`union all`, 这个和union通过临时表存储数据有关, 详细请见<高性能MySQL>关于union的优化建议.
  - 还有其他常见的优化一般在子查询优化上, 有时间再说

### 从数据库的索引说起

先说为什么要有索引, 索引是MySQL组织数据的一种方式, 虽然数据库中的数据给人直观的感受是列表形式存在的, 但是由于列表的查询性能属于O(n)级别, 对于大规模的数据查询效果并不好, 所以Mysql以B树的结构组织数据.

- Q: 为什么不是二叉树呢? 
- A: 因为二叉树存在退化的问题, 搜索复杂度也有一定几率会降为O(n). 而B树因为自身的特性并不会发生退化. 而且B树多叉, 多叉导致的结果是整棵树的高度会低, 高度低所影响的是log(n)的底数会变大.
   
B树的全称是Balancing-Tree, 是一种多路平衡树, 最大的特点是所有的叶子节点的高度相同. B树的平衡,搜索就不再说了. Mongo组织文件就是B树的结构, 而Mysql内部的索引一般采用的B+Tree的结构, ([为什么Mongo使用B树而不是B+树](https://www.cnblogs.com/rjzheng/p/12316685.html)).
  
B+树与B树的最大的区别在于B+树的内部节点不存储数据, 所有的数据都在B+树的叶子节点, B+树的叶子节点是链表并且B+树的叶子节点有next指针指向相邻的叶子节点.  

再回到索引上, 索引的具体实现取决于Mysql使用的存储引擎,  主流的是Innodb和MyISAM. 在Innodb中默认以聚集索引的形式组织数据而MyISAM采用的是非聚集索引. 详细介绍下两种索引的组织方式. 

基本现在所有建表都会要求建立主键并且自增(不一定是Auto_Increment, 还有snowflake), 必须建立主键是根据Innodb的聚集索引的特性决定的, 而自增性其实是因为B树的性质, 自增可以避免B树频繁的平衡自身, 减少插入索引数据的代价. 那么Innodb必须设置主键是因为在B+树的实现上, Innodb内部的数据指针存储的是主键的值 + 数据,  如果不设置主键, 先选择一个可以唯一标识的列作为主键, 最后都没有的话Innodb会隐式的建立一个主键用以组织数据. 而在MyISAM里面叶子节点里面存储的是数据指针, 指向了这个数据的文件位置, 这个是因为MyISAM的索引文件和数据文件是分开的, 而Innodb的数据就在叶子节点上, 所以找到了主键也就找到了数据, 因此对于非主键索引来说,  生成的索引树的叶子节点存储的是主键值, 所以根据非聚集索引查询需要回表根据主键去取数据. 这种方式就产生了一种sql优化方式叫做延迟关联, 大体的做法是内层select根据条件获取主键的值, 然后根据主键的值join自身去获取额外的数据. 而且, 因为Innodb和MyISAM这种差异, 导致了Innodb和MyISAM的一个不同是Innodb支持行级锁而MyISAM只支持表锁, 这在并发上是很大的区别. 

### 从传统的优化方式说起

+ 索引不使用表达式
+ 索引覆盖查询
+ 索引最左前缀
+ order by 和group by的列使用索引列